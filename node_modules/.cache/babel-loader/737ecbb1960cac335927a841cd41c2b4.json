{"ast":null,"code":"import { __rest, __assign } from 'tslib';\nimport arrayMove from 'array-move';\nimport React from 'react';\n/**\r\n * This function check if a given point is inside of the items rect.\r\n * If it's not inside any rect, it will return the index of the closest rect\r\n */\n\nvar findItemIndexAtPosition = function findItemIndexAtPosition(_a, itemsRect, _b) {\n  var x = _a.x,\n      y = _a.y;\n  var _c = (_b === void 0 ? {} : _b).fallbackToClosest,\n      fallbackToClosest = _c === void 0 ? false : _c;\n  var smallestDistance = 10000;\n  var smallestDistanceIndex = -1;\n\n  for (var index = 0; index < itemsRect.length; index += 1) {\n    var rect = itemsRect[index]; // if it's inside the rect, we return the current index directly\n\n    if (x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom) {\n      return index;\n    }\n\n    if (fallbackToClosest) {\n      // otherwise we compute the distance and update the smallest distance index if needed\n      var itemCenterX = (rect.left + rect.right) / 2;\n      var itemCenterY = (rect.top + rect.bottom) / 2;\n      var distance = Math.sqrt(Math.pow(x - itemCenterX, 2) + Math.pow(y - itemCenterY, 2)); // ** 2 operator is not supported on IE11\n\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        smallestDistanceIndex = index;\n      }\n    }\n  }\n\n  return smallestDistanceIndex;\n};\n\nvar getMousePoint = function getMousePoint(e) {\n  return {\n    x: Number(e.clientX),\n    y: Number(e.clientY)\n  };\n};\n\nvar getTouchPoint = function getTouchPoint(touch) {\n  return {\n    x: Number(touch.clientX),\n    y: Number(touch.clientY)\n  };\n};\n\nvar getPointInContainer = function getPointInContainer(point, containerTopLeft) {\n  return {\n    x: point.x - containerTopLeft.x,\n    y: point.y - containerTopLeft.y\n  };\n};\n\nvar preventDefault = function preventDefault(event) {\n  event.preventDefault();\n};\n\nvar disableContextMenu = function disableContextMenu() {\n  window.addEventListener('contextmenu', preventDefault, {\n    capture: true,\n    passive: false\n  });\n};\n\nvar enableContextMenu = function enableContextMenu() {\n  window.removeEventListener('contextmenu', preventDefault);\n};\n\nvar useDrag = function useDrag(_a) {\n  var onStart = _a.onStart,\n      onMove = _a.onMove,\n      onEnd = _a.onEnd,\n      containerRef = _a.containerRef,\n      knobs = _a.knobs; // contains the top-left coordinates of the container in the window. Set on drag start and used in drag move\n\n  var containerPositionRef = React.useRef({\n    x: 0,\n    y: 0\n  }); // on touch devices, we only start the drag gesture after pressing the item 200ms.\n  // this ref contains the timer id to be able to cancel it\n\n  var handleTouchStartTimerRef = React.useRef(undefined); // on non-touch device, we don't call onStart on mouse down but on the first mouse move\n  // we do this to let the user clicks on clickable element inside the container\n  // this means that the drag gesture actually starts on the fist move\n\n  var isFirstMoveRef = React.useRef(false); // see https://twitter.com/ValentinHervieu/status/1324407814970920968\n  // we do this so that the parent doesn't have to use `useCallback()` for these callbacks\n\n  var callbacksRef = React.useRef({\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  }); // instead of relying on hacks to know if the device is a touch device or not,\n  // we track this using an onTouchStart listener on the document. (see https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685)\n\n  var _b = React.useState(false),\n      isTouchDevice = _b[0],\n      setTouchDevice = _b[1];\n\n  React.useEffect(function () {\n    callbacksRef.current = {\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    };\n  }, [onStart, onMove, onEnd]);\n\n  var cancelTouchStart = function cancelTouchStart() {\n    if (handleTouchStartTimerRef.current) {\n      window.clearTimeout(handleTouchStartTimerRef.current);\n    }\n  };\n\n  var saveContainerPosition = React.useCallback(function () {\n    if (containerRef.current) {\n      var bounds = containerRef.current.getBoundingClientRect();\n      containerPositionRef.current = {\n        x: bounds.left,\n        y: bounds.top\n      };\n    }\n  }, [containerRef]);\n  var onDrag = React.useCallback(function (pointInWindow) {\n    var point = getPointInContainer(pointInWindow, containerPositionRef.current);\n\n    if (callbacksRef.current.onMove) {\n      callbacksRef.current.onMove({\n        pointInWindow: pointInWindow,\n        point: point\n      });\n    }\n  }, []);\n  var onMouseMove = React.useCallback(function (e) {\n    // if this is the first move, we trigger the onStart logic\n    if (isFirstMoveRef.current) {\n      isFirstMoveRef.current = false;\n      var pointInWindow = getMousePoint(e);\n      var point = getPointInContainer(pointInWindow, containerPositionRef.current);\n\n      if (callbacksRef.current.onStart) {\n        callbacksRef.current.onStart({\n          point: point,\n          pointInWindow: pointInWindow\n        });\n      }\n    } // otherwise, we do the normal move logic\n    else {\n        onDrag(getMousePoint(e));\n      }\n  }, [onDrag]);\n  var onTouchMove = React.useCallback(function (e) {\n    if (e.cancelable) {\n      // Prevent the whole page from scrolling\n      e.preventDefault();\n      onDrag(getTouchPoint(e.touches[0]));\n    } else {\n      // if the event is not cancelable, it means the browser is currently scrolling\n      // which cannot be interrupted. Thus we cancel the drag gesture.\n      document.removeEventListener('touchmove', onTouchMove);\n\n      if (callbacksRef.current.onEnd) {\n        callbacksRef.current.onEnd();\n      }\n    }\n  }, [onDrag]);\n  var onMouseUp = React.useCallback(function () {\n    isFirstMoveRef.current = false;\n    document.removeEventListener('mousemove', onMouseMove);\n    document.removeEventListener('mouseup', onMouseUp);\n\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd();\n    }\n  }, [onMouseMove]);\n  var onTouchEnd = React.useCallback(function () {\n    document.removeEventListener('touchmove', onTouchMove);\n    document.removeEventListener('touchend', onTouchEnd);\n    enableContextMenu();\n\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd();\n    }\n  }, [onTouchMove]);\n  var onMouseDown = React.useCallback(function (e) {\n    if (e.button !== 0) {\n      // we don't want to handle clicks other than left ones\n      return;\n    }\n\n    if ((knobs === null || knobs === void 0 ? void 0 : knobs.length) && !knobs.find(function (knob) {\n      return knob.contains(e.target);\n    })) {\n      return;\n    }\n\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    saveContainerPosition(); // mark the next move as being the first one\n\n    isFirstMoveRef.current = true;\n  }, [onMouseMove, onMouseUp, saveContainerPosition, knobs]);\n  var handleTouchStart = React.useCallback(function (point, pointInWindow) {\n    document.addEventListener('touchmove', onTouchMove, {\n      capture: false,\n      passive: false\n    });\n    document.addEventListener('touchend', onTouchEnd);\n    disableContextMenu();\n\n    if (callbacksRef.current.onStart) {\n      callbacksRef.current.onStart({\n        point: point,\n        pointInWindow: pointInWindow\n      });\n    }\n  }, [onTouchEnd, onTouchMove]);\n  var onTouchStart = React.useCallback(function (e) {\n    if ((knobs === null || knobs === void 0 ? void 0 : knobs.length) && !knobs.find(function (knob) {\n      return knob.contains(e.target);\n    })) {\n      return;\n    }\n\n    saveContainerPosition();\n    var pointInWindow = getTouchPoint(e.touches[0]);\n    var point = getPointInContainer(pointInWindow, containerPositionRef.current); // we wait 120ms to start the gesture to be sure that the user\n    // is not trying to scroll the page\n\n    handleTouchStartTimerRef.current = window.setTimeout(function () {\n      return handleTouchStart(point, pointInWindow);\n    }, 120);\n  }, [handleTouchStart, saveContainerPosition, knobs]);\n  var detectTouchDevice = React.useCallback(function () {\n    setTouchDevice(true);\n    document.removeEventListener('touchstart', detectTouchDevice);\n  }, []); // if the user is scrolling on mobile, we cancel the drag gesture\n\n  var touchScrollListener = React.useCallback(function () {\n    cancelTouchStart();\n  }, []);\n  React.useLayoutEffect(function () {\n    if (isTouchDevice) {\n      var container_1 = containerRef.current;\n      container_1 === null || container_1 === void 0 ? void 0 : container_1.addEventListener('touchstart', onTouchStart, {\n        capture: true,\n        passive: false\n      }); // we are adding this touchmove listener to cancel drag if user is scrolling\n      // however, it's also important to have a touchmove listener always set\n      // with non-capture and non-passive option to prevent an issue on Safari\n      // with e.preventDefault (https://github.com/atlassian/react-beautiful-dnd/issues/1374)\n\n      document.addEventListener('touchmove', touchScrollListener, {\n        capture: false,\n        passive: false\n      });\n      document.addEventListener('touchend', touchScrollListener, {\n        capture: false,\n        passive: false\n      });\n      return function () {\n        container_1 === null || container_1 === void 0 ? void 0 : container_1.removeEventListener('touchstart', onTouchStart);\n        document.removeEventListener('touchmove', touchScrollListener);\n        document.removeEventListener('touchend', touchScrollListener);\n        document.removeEventListener('touchmove', onTouchMove);\n        document.removeEventListener('touchend', onTouchEnd);\n        enableContextMenu();\n        cancelTouchStart();\n      };\n    } // if non-touch device\n\n\n    document.addEventListener('touchstart', detectTouchDevice);\n    return function () {\n      document.removeEventListener('touchstart', detectTouchDevice);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [isTouchDevice, detectTouchDevice, onMouseMove, onTouchMove, touchScrollListener, onTouchEnd, onMouseUp, containerRef, onTouchStart]); // on touch devices, we cannot attach the onTouchStart directly via React:\n  // Touch handlers must be added with {passive: false} to be cancelable.\n  // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n\n  return isTouchDevice ? {} : {\n    onMouseDown: onMouseDown\n  };\n};\n\nvar DEFAULT_CONTAINER_TAG = 'div';\nvar SortableListContext = /*#__PURE__*/React.createContext(undefined);\n\nvar SortableList = function SortableList(_a) {\n  var children = _a.children,\n      _b = _a.allowDrag,\n      allowDrag = _b === void 0 ? true : _b,\n      onSortEnd = _a.onSortEnd,\n      draggedItemClassName = _a.draggedItemClassName,\n      as = _a.as,\n      rest = __rest(_a, [\"children\", \"allowDrag\", \"onSortEnd\", \"draggedItemClassName\", \"as\"]); // this array contains the elements than can be sorted (wrapped inside SortableItem)\n\n\n  var itemsRef = React.useRef([]); // this array contains the coordinates of each sortable element (only computed on dragStart and used in dragMove for perf reason)\n\n  var itemsRect = React.useRef([]); // Hold all registered knobs\n\n  var knobs = React.useRef([]); // contains the container element\n\n  var containerRef = React.useRef(null); // contains the target element (copy of the source element)\n\n  var targetRef = React.useRef(null); // contains the index in the itemsRef array of the element being dragged\n\n  var sourceIndexRef = React.useRef(undefined); // contains the index in the itemsRef of the element to be exchanged with the source item\n\n  var lastTargetIndexRef = React.useRef(undefined); // contains the offset point where the initial drag occurred to be used when dragging the item\n\n  var offsetPointRef = React.useRef({\n    x: 0,\n    y: 0\n  });\n  React.useEffect(function () {\n    return function () {\n      // cleanup the target element from the DOM when SortableList in unmounted\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current);\n      }\n    };\n  }, []);\n\n  var updateTargetPosition = function updateTargetPosition(position) {\n    if (targetRef.current) {\n      var offset = offsetPointRef.current; // we use `translate3d` to force using the GPU if available\n\n      targetRef.current.style.transform = \"translate3d(\" + (position.x - offset.x) + \"px, \" + (position.y - offset.y) + \"px, 0px)\";\n    }\n  };\n\n  var copyItem = React.useCallback(function (sourceIndex) {\n    if (!containerRef.current) {\n      return;\n    }\n\n    var source = itemsRef.current[sourceIndex];\n    var sourceRect = itemsRect.current[sourceIndex];\n    var copy = source.cloneNode(true); // added the \"dragged\" class name\n\n    if (draggedItemClassName) {\n      draggedItemClassName.split(' ').forEach(function (c) {\n        return copy.classList.add(c);\n      });\n    } // we ensure the copy has the same size than the source element\n\n\n    copy.style.width = sourceRect.width + \"px\";\n    copy.style.height = sourceRect.height + \"px\"; // we place the target starting position to the top left of the window\n    // it will then be moved relatively using `transform: translate3d()`\n\n    copy.style.position = 'fixed';\n    copy.style.margin = '0';\n    copy.style.top = '0';\n    copy.style.left = '0';\n    var sourceCanvases = source.querySelectorAll('canvas');\n    copy.querySelectorAll('canvas').forEach(function (canvas, index) {\n      var _a;\n\n      (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(sourceCanvases[index], 0, 0);\n    });\n    document.body.appendChild(copy);\n    targetRef.current = copy;\n  }, [draggedItemClassName]);\n  var listeners = useDrag({\n    containerRef: containerRef,\n    knobs: knobs.current,\n    onStart: function onStart(_a) {\n      var pointInWindow = _a.pointInWindow;\n\n      if (!containerRef.current) {\n        return;\n      }\n\n      itemsRect.current = itemsRef.current.map(function (item) {\n        return item.getBoundingClientRect();\n      });\n      var sourceIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current); // if we are not starting the drag gesture on a SortableItem, we exit early\n\n      if (sourceIndex === -1) {\n        return;\n      } // saving the index of the item being dragged\n\n\n      sourceIndexRef.current = sourceIndex; // the item being dragged is copied to the document body and will be used as the target\n\n      copyItem(sourceIndex); // hide source during the drag gesture\n\n      var source = itemsRef.current[sourceIndex];\n      source.style.opacity = '0';\n      source.style.visibility = 'hidden'; // get the offset between the source item's window position relative to the point in window\n\n      var sourceRect = source.getBoundingClientRect();\n      offsetPointRef.current = {\n        x: pointInWindow.x - sourceRect.left,\n        y: pointInWindow.y - sourceRect.top\n      };\n      updateTargetPosition(pointInWindow); // Adds a nice little physical feedback\n\n      if (window.navigator.vibrate) {\n        window.navigator.vibrate(100);\n      }\n    },\n    onMove: function onMove(_a) {\n      var pointInWindow = _a.pointInWindow;\n      updateTargetPosition(pointInWindow);\n      var sourceIndex = sourceIndexRef.current; // if there is no source, we exit early (happened when drag gesture was started outside a SortableItem)\n\n      if (sourceIndex === undefined) {\n        return;\n      }\n\n      var targetIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current, {\n        fallbackToClosest: true\n      }); // if not target detected, we don't need to update other items' position\n\n      if (targetIndex === -1) {\n        return;\n      } // we keep track of the last target index (to be passed to the onSortEnd callback)\n\n\n      lastTargetIndexRef.current = targetIndex;\n      var isMovingRight = sourceIndex < targetIndex; // in this loop, we go over each sortable item and see if we need to update their position\n\n      for (var index = 0; index < itemsRef.current.length; index += 1) {\n        var currentItem = itemsRef.current[index];\n        var currentItemRect = itemsRect.current[index]; // if current index is between sourceIndex and targetIndex, we need to translate them\n\n        if (isMovingRight && index >= sourceIndex && index <= targetIndex || !isMovingRight && index >= targetIndex && index <= sourceIndex) {\n          // we need to move the item to the previous or next item position\n          var nextItemRects = itemsRect.current[isMovingRight ? index - 1 : index + 1];\n\n          if (nextItemRects) {\n            var translateX = nextItemRects.left - currentItemRect.left;\n            var translateY = nextItemRects.top - currentItemRect.top; // we use `translate3d` to force using the GPU if available\n\n            currentItem.style.transform = \"translate3d(\" + translateX + \"px, \" + translateY + \"px, 0px)\";\n          }\n        } // otherwise, the item should be at its original position\n        else {\n            currentItem.style.transform = 'translate3d(0,0,0)';\n          } // we want the translation to be animated\n\n\n        currentItem.style.transitionDuration = '300ms';\n      }\n    },\n    onEnd: function onEnd() {\n      // we reset all items translations (the parent is expected to sort the items in the onSortEnd callback)\n      for (var index = 0; index < itemsRef.current.length; index += 1) {\n        var currentItem = itemsRef.current[index];\n        currentItem.style.transform = '';\n        currentItem.style.transitionDuration = '';\n      }\n\n      var sourceIndex = sourceIndexRef.current;\n\n      if (sourceIndex !== undefined) {\n        // show the source item again\n        var source = itemsRef.current[sourceIndex];\n\n        if (source) {\n          source.style.opacity = '1';\n          source.style.visibility = '';\n        }\n\n        var targetIndex = lastTargetIndexRef.current;\n\n        if (targetIndex !== undefined) {\n          if (sourceIndex !== targetIndex) {\n            // sort our internal items array\n            itemsRef.current = arrayMove(itemsRef.current, sourceIndex, targetIndex); // let the parent know\n\n            onSortEnd(sourceIndex, targetIndex);\n          }\n        }\n      }\n\n      sourceIndexRef.current = undefined;\n      lastTargetIndexRef.current = undefined; // cleanup the target element from the DOM\n\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current);\n        targetRef.current = null;\n      }\n    }\n  });\n  var registerItem = React.useCallback(function (item) {\n    itemsRef.current.push(item);\n  }, []);\n  var removeItem = React.useCallback(function (item) {\n    var index = itemsRef.current.indexOf(item);\n\n    if (index !== -1) {\n      itemsRef.current.splice(index, 1);\n    }\n  }, []);\n  var registerKnob = React.useCallback(function (item) {\n    knobs.current.push(item);\n  }, []);\n  var removeKnob = React.useCallback(function (item) {\n    var index = knobs.current.indexOf(item);\n\n    if (index !== -1) {\n      knobs.current.splice(index, 1);\n    }\n  }, []); // we need to memoize the context to avoid re-rendering every children of the context provider\n  // when not needed\n\n  var context = React.useMemo(function () {\n    return {\n      registerItem: registerItem,\n      removeItem: removeItem,\n      registerKnob: registerKnob,\n      removeKnob: removeKnob\n    };\n  }, [registerItem, removeItem, registerKnob, removeKnob]);\n  return /*#__PURE__*/React.createElement(as || DEFAULT_CONTAINER_TAG, __assign(__assign(__assign({}, allowDrag ? listeners : {}), rest), {\n    ref: containerRef\n  }), /*#__PURE__*/React.createElement(SortableListContext.Provider, {\n    value: context\n  }, children));\n};\n/**\r\n * SortableItem only adds a ref to its children so that we can register it to the main Sortable\r\n */\n\n\nvar SortableItem = function SortableItem(_a) {\n  var children = _a.children;\n  var context = React.useContext(SortableListContext);\n\n  if (!context) {\n    throw new Error('SortableItem must be a child of SortableList');\n  }\n\n  var registerItem = context.registerItem,\n      removeItem = context.removeItem;\n  var elementRef = React.useRef(null);\n  React.useEffect(function () {\n    var currentItem = elementRef.current;\n\n    if (currentItem) {\n      registerItem(currentItem);\n    }\n\n    return function () {\n      if (currentItem) {\n        removeItem(currentItem);\n      }\n    }; // if the children changes, we want to re-register the DOM node\n  }, [registerItem, removeItem, children]);\n  return /*#__PURE__*/React.cloneElement(children, {\n    ref: elementRef\n  });\n};\n\nvar SortableKnob = function SortableKnob(_a) {\n  var children = _a.children;\n  var context = React.useContext(SortableListContext);\n\n  if (!context) {\n    throw new Error('SortableKnob must be a child of SortableList');\n  }\n\n  var registerKnob = context.registerKnob,\n      removeKnob = context.removeKnob;\n  var elementRef = React.useRef(null);\n  React.useEffect(function () {\n    var currentItem = elementRef.current;\n\n    if (currentItem) {\n      registerKnob(currentItem);\n    }\n\n    return function () {\n      if (currentItem) {\n        removeKnob(currentItem);\n      }\n    }; // if the children changes, we want to re-register the DOM node\n  }, [registerKnob, removeKnob, children]);\n  return /*#__PURE__*/React.cloneElement(children, {\n    ref: elementRef\n  });\n};\n\nexport default SortableList;\nexport { SortableItem, SortableKnob };","map":{"version":3,"sources":["../src/helpers.ts","../src/hooks.ts","../src/index.tsx"],"names":["findItemIndexAtPosition","x","y","_c","smallestDistance","smallestDistanceIndex","index","itemsRect","rect","itemCenterX","itemCenterY","distance","Math","getMousePoint","Number","e","getTouchPoint","touch","getPointInContainer","point","containerTopLeft","preventDefault","event","disableContextMenu","window","capture","passive","enableContextMenu","useDrag","onStart","onMove","onEnd","containerRef","knobs","containerPositionRef","handleTouchStartTimerRef","React","isFirstMoveRef","callbacksRef","isTouchDevice","setTouchDevice","cancelTouchStart","saveContainerPosition","bounds","top","onDrag","pointInWindow","onMouseMove","onTouchMove","document","onMouseUp","onTouchEnd","onMouseDown","handleTouchStart","onTouchStart","detectTouchDevice","touchScrollListener","container_1","DEFAULT_CONTAINER_TAG","SortableListContext","SortableList","_b","onSortEnd","draggedItemClassName","as","rest","itemsRef","targetRef","sourceIndexRef","lastTargetIndexRef","offsetPointRef","updateTargetPosition","offset","position","copyItem","source","sourceRect","copy","sourceCanvases","drawImage","listeners","sourceIndex","targetIndex","fallbackToClosest","isMovingRight","currentItem","currentItemRect","nextItemRects","translateX","translateY","arrayMove","registerItem","removeItem","registerKnob","removeKnob","context","allowDrag","ref","value","SortableItem","children","elementRef","SortableKnob"],"mappings":"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","sourcesContent":["import { Point } from './types'\n\n/**\n * This function check if a given point is inside of the items rect.\n * If it's not inside any rect, it will return the index of the closest rect\n */\nexport const findItemIndexAtPosition = (\n  { x, y }: Point,\n  itemsRect: DOMRect[],\n  { fallbackToClosest = false } = {}\n): number => {\n  let smallestDistance = 10000\n  let smallestDistanceIndex = -1\n  for (let index = 0; index < itemsRect.length; index += 1) {\n    const rect = itemsRect[index]\n    // if it's inside the rect, we return the current index directly\n    if (x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom) {\n      return index\n    }\n    if (fallbackToClosest) {\n      // otherwise we compute the distance and update the smallest distance index if needed\n      const itemCenterX = (rect.left + rect.right) / 2\n      const itemCenterY = (rect.top + rect.bottom) / 2\n\n      const distance = Math.sqrt(Math.pow(x - itemCenterX, 2) + Math.pow(y - itemCenterY, 2)) // ** 2 operator is not supported on IE11\n      if (distance < smallestDistance) {\n        smallestDistance = distance\n        smallestDistanceIndex = index\n      }\n    }\n  }\n  return smallestDistanceIndex\n}\n","import React from 'react'\n\nimport { Point } from './types'\n\nconst getMousePoint = (e: MouseEvent | React.MouseEvent): Point => ({\n  x: Number(e.clientX),\n  y: Number(e.clientY),\n})\n\nconst getTouchPoint = (touch: Touch | React.Touch): Point => ({\n  x: Number(touch.clientX),\n  y: Number(touch.clientY),\n})\n\nconst getPointInContainer = (point: Point, containerTopLeft: Point): Point => {\n  return {\n    x: point.x - containerTopLeft.x,\n    y: point.y - containerTopLeft.y,\n  }\n}\n\nconst preventDefault = (event: Event) => {\n  event.preventDefault()\n}\n\nconst disableContextMenu = () => {\n  window.addEventListener('contextmenu', preventDefault, { capture: true, passive: false })\n}\n\nconst enableContextMenu = () => {\n  window.removeEventListener('contextmenu', preventDefault)\n}\n\nexport type OnStartArgs = { point: Point; pointInWindow: Point }\nexport type OnMoveArgs = { point: Point; pointInWindow: Point }\n\ntype UseDragProps = {\n  onStart?: (args: OnStartArgs) => void\n  onMove?: (args: OnMoveArgs) => void\n  onEnd?: () => void\n  containerRef: React.MutableRefObject<HTMLElement | null>\n  knobs?: HTMLElement[]\n}\n\nexport const useDrag = ({ onStart, onMove, onEnd, containerRef, knobs }: UseDragProps) => {\n  // contains the top-left coordinates of the container in the window. Set on drag start and used in drag move\n  const containerPositionRef = React.useRef<Point>({ x: 0, y: 0 })\n  // on touch devices, we only start the drag gesture after pressing the item 200ms.\n  // this ref contains the timer id to be able to cancel it\n  const handleTouchStartTimerRef = React.useRef<number | undefined>(undefined)\n  // on non-touch device, we don't call onStart on mouse down but on the first mouse move\n  // we do this to let the user clicks on clickable element inside the container\n  // this means that the drag gesture actually starts on the fist move\n  const isFirstMoveRef = React.useRef(false)\n  // see https://twitter.com/ValentinHervieu/status/1324407814970920968\n  // we do this so that the parent doesn't have to use `useCallback()` for these callbacks\n  const callbacksRef = React.useRef({ onStart, onMove, onEnd })\n\n  // instead of relying on hacks to know if the device is a touch device or not,\n  // we track this using an onTouchStart listener on the document. (see https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685)\n  const [isTouchDevice, setTouchDevice] = React.useState(false)\n\n  React.useEffect(() => {\n    callbacksRef.current = { onStart, onMove, onEnd }\n  }, [onStart, onMove, onEnd])\n\n  const cancelTouchStart = () => {\n    if (handleTouchStartTimerRef.current) {\n      window.clearTimeout(handleTouchStartTimerRef.current)\n    }\n  }\n\n  const saveContainerPosition = React.useCallback(() => {\n    if (containerRef.current) {\n      const bounds = containerRef.current.getBoundingClientRect()\n      containerPositionRef.current = { x: bounds.left, y: bounds.top }\n    }\n  }, [containerRef])\n\n  const onDrag = React.useCallback((pointInWindow: Point) => {\n    const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n    if (callbacksRef.current.onMove) {\n      callbacksRef.current.onMove({ pointInWindow, point })\n    }\n  }, [])\n\n  const onMouseMove = React.useCallback(\n    (e: MouseEvent) => {\n      // if this is the first move, we trigger the onStart logic\n      if (isFirstMoveRef.current) {\n        isFirstMoveRef.current = false\n        const pointInWindow = getMousePoint(e)\n        const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n        if (callbacksRef.current.onStart) {\n          callbacksRef.current.onStart({ point, pointInWindow })\n        }\n      }\n      // otherwise, we do the normal move logic\n      else {\n        onDrag(getMousePoint(e))\n      }\n    },\n    [onDrag]\n  )\n\n  const onTouchMove = React.useCallback(\n    (e: TouchEvent) => {\n      if (e.cancelable) {\n        // Prevent the whole page from scrolling\n        e.preventDefault()\n        onDrag(getTouchPoint(e.touches[0]))\n      } else {\n        // if the event is not cancelable, it means the browser is currently scrolling\n        // which cannot be interrupted. Thus we cancel the drag gesture.\n        document.removeEventListener('touchmove', onTouchMove)\n        if (callbacksRef.current.onEnd) {\n          callbacksRef.current.onEnd()\n        }\n      }\n    },\n    [onDrag]\n  )\n\n  const onMouseUp = React.useCallback(() => {\n    isFirstMoveRef.current = false\n    document.removeEventListener('mousemove', onMouseMove)\n    document.removeEventListener('mouseup', onMouseUp)\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onMouseMove])\n\n  const onTouchEnd = React.useCallback(() => {\n    document.removeEventListener('touchmove', onTouchMove)\n    document.removeEventListener('touchend', onTouchEnd)\n    enableContextMenu()\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onTouchMove])\n\n  const onMouseDown = React.useCallback(\n    (e: React.MouseEvent<HTMLElement, MouseEvent>) => {\n      if (e.button !== 0) {\n        // we don't want to handle clicks other than left ones\n        return\n      }\n\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      document.addEventListener('mousemove', onMouseMove)\n      document.addEventListener('mouseup', onMouseUp)\n\n      saveContainerPosition()\n\n      // mark the next move as being the first one\n      isFirstMoveRef.current = true\n    },\n    [onMouseMove, onMouseUp, saveContainerPosition, knobs]\n  )\n\n  const handleTouchStart = React.useCallback(\n    (point: Point, pointInWindow: Point) => {\n      document.addEventListener('touchmove', onTouchMove, { capture: false, passive: false })\n      document.addEventListener('touchend', onTouchEnd)\n      disableContextMenu()\n\n      if (callbacksRef.current.onStart) {\n        callbacksRef.current.onStart({ point, pointInWindow })\n      }\n    },\n    [onTouchEnd, onTouchMove]\n  )\n\n  const onTouchStart = React.useCallback(\n    (e: TouchEvent) => {\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      saveContainerPosition()\n\n      const pointInWindow = getTouchPoint(e.touches[0])\n      const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n\n      // we wait 120ms to start the gesture to be sure that the user\n      // is not trying to scroll the page\n      handleTouchStartTimerRef.current = window.setTimeout(\n        () => handleTouchStart(point, pointInWindow),\n        120\n      )\n    },\n    [handleTouchStart, saveContainerPosition, knobs]\n  )\n\n  const detectTouchDevice = React.useCallback(() => {\n    setTouchDevice(true)\n    document.removeEventListener('touchstart', detectTouchDevice)\n  }, [])\n\n  // if the user is scrolling on mobile, we cancel the drag gesture\n  const touchScrollListener = React.useCallback(() => {\n    cancelTouchStart()\n  }, [])\n\n  React.useLayoutEffect(() => {\n    if (isTouchDevice) {\n      const container = containerRef.current\n      container?.addEventListener('touchstart', onTouchStart, { capture: true, passive: false })\n      // we are adding this touchmove listener to cancel drag if user is scrolling\n      // however, it's also important to have a touchmove listener always set\n      // with non-capture and non-passive option to prevent an issue on Safari\n      // with e.preventDefault (https://github.com/atlassian/react-beautiful-dnd/issues/1374)\n      document.addEventListener('touchmove', touchScrollListener, {\n        capture: false,\n        passive: false,\n      })\n      document.addEventListener('touchend', touchScrollListener, {\n        capture: false,\n        passive: false,\n      })\n\n      return () => {\n        container?.removeEventListener('touchstart', onTouchStart)\n        document.removeEventListener('touchmove', touchScrollListener)\n        document.removeEventListener('touchend', touchScrollListener)\n        document.removeEventListener('touchmove', onTouchMove)\n        document.removeEventListener('touchend', onTouchEnd)\n        enableContextMenu()\n        cancelTouchStart()\n      }\n    }\n    // if non-touch device\n    document.addEventListener('touchstart', detectTouchDevice)\n    return () => {\n      document.removeEventListener('touchstart', detectTouchDevice)\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n    }\n  }, [\n    isTouchDevice,\n    detectTouchDevice,\n    onMouseMove,\n    onTouchMove,\n    touchScrollListener,\n    onTouchEnd,\n    onMouseUp,\n    containerRef,\n    onTouchStart,\n  ])\n\n  // on touch devices, we cannot attach the onTouchStart directly via React:\n  // Touch handlers must be added with {passive: false} to be cancelable.\n  // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n  return isTouchDevice ? {} : { onMouseDown }\n}\n","import arrayMove from 'array-move'\nimport React, { HTMLAttributes } from 'react'\n\nimport { findItemIndexAtPosition } from './helpers'\nimport { useDrag } from './hooks'\nimport { Point } from './types'\n\nconst DEFAULT_CONTAINER_TAG = 'div'\n\ntype Props<TTag extends keyof JSX.IntrinsicElements> = HTMLAttributes<TTag> & {\n  children: React.ReactNode\n  /** Determines whether drag functionality is enabled, defaults to true */\n  allowDrag?: boolean\n  /** Called when the user finishes a sorting gesture. */\n  onSortEnd: (oldIndex: number, newIndex: number) => void\n  /** Class applied to the item being dragged */\n  draggedItemClassName?: string\n  /** Determines which type of html tag will be used for a container element */\n  as?: TTag\n}\n\n// this context is only used so that SortableItems can register/remove themselves\n// from the items list\ntype Context = {\n  registerItem: (item: HTMLElement) => void\n  removeItem: (item: HTMLElement) => void\n  registerKnob:  (item: HTMLElement) => void\n  removeKnob:  (item: HTMLElement) => void\n}\n\nconst SortableListContext = React.createContext<Context | undefined>(undefined)\nconst SortableList = <TTag extends keyof JSX.IntrinsicElements = typeof DEFAULT_CONTAINER_TAG>({ children, allowDrag = true, onSortEnd, draggedItemClassName, as, ...rest }: Props<TTag>) => {\n  // this array contains the elements than can be sorted (wrapped inside SortableItem)\n  const itemsRef = React.useRef<HTMLElement[]>([])\n  // this array contains the coordinates of each sortable element (only computed on dragStart and used in dragMove for perf reason)\n  const itemsRect = React.useRef<DOMRect[]>([])\n  // Hold all registered knobs\n  const knobs = React.useRef<HTMLElement[]>([]);\n  // contains the container element\n  const containerRef = React.useRef<HTMLElement | null>(null)\n  // contains the target element (copy of the source element)\n  const targetRef = React.useRef<HTMLElement | null>(null)\n  // contains the index in the itemsRef array of the element being dragged\n  const sourceIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the index in the itemsRef of the element to be exchanged with the source item\n  const lastTargetIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the offset point where the initial drag occurred to be used when dragging the item\n  const offsetPointRef = React.useRef<Point>({ x: 0, y: 0 })\n\n  React.useEffect(() => {\n    return () => {\n      // cleanup the target element from the DOM when SortableList in unmounted\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current)\n      }\n    }\n  }, [])\n\n  const updateTargetPosition = (position: Point) => {\n    if (targetRef.current) {\n      const offset = offsetPointRef.current\n\n      // we use `translate3d` to force using the GPU if available\n      targetRef.current.style.transform = `translate3d(${position.x - offset.x}px, ${\n        position.y - offset.y\n      }px, 0px)`\n    }\n  }\n\n  const copyItem = React.useCallback(\n    (sourceIndex: number) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      const source = itemsRef.current[sourceIndex]\n      const sourceRect = itemsRect.current[sourceIndex]\n\n      const copy = source.cloneNode(true) as HTMLElement\n\n      // added the \"dragged\" class name\n      if (draggedItemClassName) {\n        draggedItemClassName.split(' ').forEach((c) => copy.classList.add(c))\n      }\n\n      // we ensure the copy has the same size than the source element\n      copy.style.width = `${sourceRect.width}px`\n      copy.style.height = `${sourceRect.height}px`\n      // we place the target starting position to the top left of the window\n      // it will then be moved relatively using `transform: translate3d()`\n      copy.style.position = 'fixed'\n      copy.style.margin = '0'\n      copy.style.top = '0'\n      copy.style.left = '0'\n\n      const sourceCanvases = source.querySelectorAll('canvas');\n      copy.querySelectorAll('canvas').forEach((canvas, index) => {\n        canvas.getContext('2d')?.drawImage(sourceCanvases[index], 0, 0);\n      });\n\n      document.body.appendChild(copy)\n\n      targetRef.current = copy\n    },\n    [draggedItemClassName]\n  )\n\n  const listeners = useDrag({\n    containerRef,\n    knobs: knobs.current,\n    onStart: ({ pointInWindow }) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      itemsRect.current = itemsRef.current.map((item) => item.getBoundingClientRect())\n\n      const sourceIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current)\n      // if we are not starting the drag gesture on a SortableItem, we exit early\n      if (sourceIndex === -1) {\n        return\n      }\n\n      // saving the index of the item being dragged\n      sourceIndexRef.current = sourceIndex\n\n      // the item being dragged is copied to the document body and will be used as the target\n      copyItem(sourceIndex)\n\n      // hide source during the drag gesture\n      const source = itemsRef.current[sourceIndex]\n      source.style.opacity = '0'\n      source.style.visibility = 'hidden'\n\n      // get the offset between the source item's window position relative to the point in window\n      const sourceRect = source.getBoundingClientRect()\n      offsetPointRef.current = {\n        x: pointInWindow.x - sourceRect.left,\n        y: pointInWindow.y - sourceRect.top,\n      }\n\n      updateTargetPosition(pointInWindow)\n\n      // Adds a nice little physical feedback\n      if (window.navigator.vibrate) {\n        window.navigator.vibrate(100)\n      }\n    },\n    onMove: ({ pointInWindow }) => {\n      updateTargetPosition(pointInWindow)\n\n      const sourceIndex = sourceIndexRef.current\n      // if there is no source, we exit early (happened when drag gesture was started outside a SortableItem)\n      if (sourceIndex === undefined) {\n        return\n      }\n\n      const targetIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current, {\n        fallbackToClosest: true,\n      })\n      // if not target detected, we don't need to update other items' position\n      if (targetIndex === -1) {\n        return\n      }\n      // we keep track of the last target index (to be passed to the onSortEnd callback)\n      lastTargetIndexRef.current = targetIndex\n\n      const isMovingRight = sourceIndex < targetIndex\n\n      // in this loop, we go over each sortable item and see if we need to update their position\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        const currentItemRect = itemsRect.current[index]\n        // if current index is between sourceIndex and targetIndex, we need to translate them\n        if (\n          (isMovingRight && index >= sourceIndex && index <= targetIndex) ||\n          (!isMovingRight && index >= targetIndex && index <= sourceIndex)\n        ) {\n          // we need to move the item to the previous or next item position\n          const nextItemRects = itemsRect.current[isMovingRight ? index - 1 : index + 1]\n          if (nextItemRects) {\n            const translateX = nextItemRects.left - currentItemRect.left\n            const translateY = nextItemRects.top - currentItemRect.top\n            // we use `translate3d` to force using the GPU if available\n            currentItem.style.transform = `translate3d(${translateX}px, ${translateY}px, 0px)`\n          }\n        }\n        // otherwise, the item should be at its original position\n        else {\n          currentItem.style.transform = 'translate3d(0,0,0)'\n        }\n        // we want the translation to be animated\n        currentItem.style.transitionDuration = '300ms'\n      }\n    },\n    onEnd: () => {\n      // we reset all items translations (the parent is expected to sort the items in the onSortEnd callback)\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        currentItem.style.transform = ''\n        currentItem.style.transitionDuration = ''\n      }\n\n      const sourceIndex = sourceIndexRef.current\n      if (sourceIndex !== undefined) {\n        // show the source item again\n        const source = itemsRef.current[sourceIndex]\n        if (source) {\n          source.style.opacity = '1'\n          source.style.visibility = ''\n        }\n\n        const targetIndex = lastTargetIndexRef.current\n        if (targetIndex !== undefined) {\n          if (sourceIndex !== targetIndex) {\n            // sort our internal items array\n            itemsRef.current = arrayMove(itemsRef.current, sourceIndex, targetIndex)\n            // let the parent know\n            onSortEnd(sourceIndex, targetIndex)\n          }\n        }\n      }\n      sourceIndexRef.current = undefined\n      lastTargetIndexRef.current = undefined\n\n      // cleanup the target element from the DOM\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current)\n        targetRef.current = null\n      }\n    },\n  })\n\n  const registerItem = React.useCallback((item: HTMLElement) => {\n    itemsRef.current.push(item)\n  }, [])\n\n  const removeItem = React.useCallback((item: HTMLElement) => {\n    const index = itemsRef.current.indexOf(item)\n    if (index !== -1) {\n      itemsRef.current.splice(index, 1)\n    }\n  }, [])\n\n  const registerKnob = React.useCallback((item: HTMLElement) => {\n    knobs.current.push(item)\n  }, [])\n\n  const removeKnob = React.useCallback((item: HTMLElement) => {\n    const index = knobs.current.indexOf(item)\n\n    if (index !== -1) {\n      knobs.current.splice(index, 1)\n    }\n  }, [])\n\n  // we need to memoize the context to avoid re-rendering every children of the context provider\n  // when not needed\n  const context = React.useMemo(() => ({ registerItem, removeItem, registerKnob, removeKnob }), [registerItem, removeItem, registerKnob, removeKnob])\n\n  return React.createElement(\n    as || DEFAULT_CONTAINER_TAG, \n    { \n      ...(allowDrag ? listeners : {}),\n      ...rest, \n      ref: containerRef\n    },\n    <SortableListContext.Provider value={context}>{children}</SortableListContext.Provider>\n  ) \n}\n\nexport default SortableList\n\ntype ItemProps = {\n  children: React.ReactElement\n}\n\n/**\n * SortableItem only adds a ref to its children so that we can register it to the main Sortable\n */\nexport const SortableItem = ({ children }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n  if (!context) {\n    throw new Error('SortableItem must be a child of SortableList')\n  }\n  const { registerItem, removeItem } = context\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n    if (currentItem) {\n      registerItem(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeItem(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerItem, removeItem, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n}\n\nexport const SortableKnob = ({ children  }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n\n  if (!context) {\n    throw new Error('SortableKnob must be a child of SortableList')\n  }\n\n  const { registerKnob, removeKnob } = context;\n\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n\n    if (currentItem) {\n      registerKnob(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeKnob(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerKnob, removeKnob, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n};\n"]},"metadata":{},"sourceType":"module"}